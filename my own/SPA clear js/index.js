// Добавляем отслеживание переключения ссылок
document.addEventListener("click", handler);
function handler(e) {
	// если элемент, по которому мы кликнули - это ссылка, то вызываем ф-цию route() и передаем в нее атрибут е (event).
	if (e.target.tagName === "A") {
		route(e);
	}
	// Чтобы браузер не пытался перейти по ссылкам, метод preventDefault() вешаем на все событие
	e.preventDefault();
}

// Опишем ф-цию роутинга, она принимает событие e от function handler, которая в свою очередь получила его от document.addEventListener
const route = (e) => {
	// Обращаемся к объекту window и к его свойству history, и вызываем метод pushState
	// С помощью History API можно переходить по истории вперёд, назад и управлять содержимым истории. Доступ к API осуществляется с помощью объекта window.history.
	// Подробнее https://doka.guide/js/window-history/
	// back() перемещает пользователя по истории на страницу назад;
	// forward() перемещает пользователя по истории на страницу вперёд;
	// go() универсальный метод для перемещения по истории вперёд или назад;
	// pushState() добавляет новую запись в истории сессии;
	// replaceState() изменяет текущую запись в истории сессии.
	// Для создания новой записи в истории используется метод pushState(), а для модификации текущей записи – replaceState().

	// Оба метода похожи с точки зрения использования и оба принимают три аргумента:

	// объект состояния, в который можно добавить любые данные, необходимые для навигации; В первый аргумент-объект можно записать любой объект с любыми данными, главное чтобы объект был сериализуемым. Браузеры могут накладывать ограничения на размер такого объекта.
	// неиспользуемый параметр, который существует по историческим причинам; Второй аргумент игнорируется всеми браузерами кроме Safari. Во избежание ошибок рекомендуют передавать пустую строку.
	// новый URL-адрес, этот параметр опциональный. Третий аргумент, URL-адрес, необязательный. Если этот аргумент не был задан, то будет использован текущий URL. Новый URL-адрес должен использовать тот же протокол, домен и порт, иначе будет выброшена ошибка. Если новая запись ведёт на новый относительный адрес, то можно не передавать адрес полностью вместе с доменом, а записать только относительную часть через слэш. Например, /profile.

	// Получается мы так создаем новую запись истории сеанса на указанном url. Т.е. виртуально переходим на другую страницу. Хотя остаемся в том же html документе. И благодаря этоту страница не обновляется.
	window.history.pushState({}, "", e.target.href);
	handleLocation();
};

// Создадим теперь html файлы наших страниц

// Создаем объект в котором пропишем соответсвие названий ссылок-названиям html файлов

const routers = {
	"/": "main.html",
	"/contacts": "contacts.html",
	"/settings": "settings.html",
};

// Создаем асинхронню функцию, которая будет подгружать наши страницы по указанному адресу handleLocation (управление положением)
 async function handleLocation () {
	// Создаем переменную для хранения адреса, который мы будем считывать с адресной строки
	// Интерфейс Location представляет собой адрес (URL) объекта, с которым он связан. Его модификации отражаются на родительском объекте.
	//Свойство pathname - строка пути (относительно хоста) (например /search) (в виде строки)
	// Фактический мы получаем первый слэш (/) и все что идет за ним в адресной строке
	// Подробнее https://developer.mozilla.org/ru/docs/Web/API/Location
	const path = window.location.pathname;
	// Создаем переменную для хранения html страницы
	// fetch это простой GET-запрос, скачивающий содержимое по адресу url. let promise = fetch(url, [options]), и возвращает промис
	// Далее мы потребляем промис. then((data)=>data.text()) .text() читает data и возвращает как обычный текст. Теперь у нас в const html - html код в виде строки.
	const html = await fetch(routers[path]).then((data) => data.text());
	// Добавляем наш html код в виде строки на страницу как обычно при помощи свойства innerHTML
	document.querySelector(".container").innerHTML = html;
};
// Теперь нам нужно вызывать нашу ф-цию handleLocation при клике на ссылку, поэтому вызываем ее в функции route() после добавления новой записи в историю

// Заменяем стандартный роутинг объекта window на наш собственный (кастомный)
window.route = route;
